# Empowering Go with WebAssembly System Interface (WASI) Unleashed

14th March 2024

Tags: wasm, wasi, wasip1
Summary: This presentation examines the current state of WebAssembly in Go, with a focus on WASI preview 1. It delves into the history of WASI development, the ecosystem of tools, and explores real-world applications.

Rajiv Ranjan Singh
Achille Roussel

## Agenda

: Achille
- The story of how this talk happened
: - An open-source tale
: - We didn't know each other; we had never met in person
: - We connected through the Go and Wasm community
: - There was low interest in this talk last year, but there is a lot of demand for it this year (thanks to Wasm I/O for the opportunity)
: - This talk is about the open-source community coming together to present what we've created

: Rajiv
- What is the Go programming language?
: - Systems programming
: - Great ecosystem for developing network services
: - Compiled language, memory-safe, with automatic memory management (garbage collected)
: - Famous for concurrency features (e.g., channels & goroutines)
: - Open-source project maintained by Google but contributed to by hundreds of developers from the community
: - Explanation of TinyGo and Big Go because this talk mostly focuses on Big Go

: Achille
- Using WebAssembly in Go
: - GOOS=wasip1 GOARCH=wasm go build
: - Show how to run tests with runtime set as GOWASIRUNTIME=wazero
: - Wrapping Wasm functions in Go with go:wasmimport

: Rajiv
- The WebAssembly System Interface
: - Introduction to WebAssembly System Interface (WASI)
: - Advantages of using WASI

: Achille
- History of WASI Support in the Go Toolchain
: - Talk about TinyGo
: - Talk about how the project started, who was involved
: - Talk about when it was released

: Rajiv
- Examples of using wasip1 in real-world programs
: - Show how to use wasip1 with Go
: - Why is WASI useful for sqlc and its plugins?

: Achille
- Limitations of wasip1
: - Network support requires third-party extensions
: - Mention Stealth Rocket again the first time we mention it at the start of the talk, now the second time.

: Rajiv
- When to use TinyGo vs Big Go in WASI?
: - TinyGo is good for a small binary footprint (for example, for browsers)
: - Big Go is good for full language features (for example, for goroutines)

: Achille
- The future of Wasm in Go
: - Will Docker and Kubernetes support WASI modules?
: - wasip2 development
: - go:wasmexport
: - GOARCH=wasm32
: - Fastly development of wasip2 on TinyGo

## Speakers

.link https://github.com/iamrajiv

- Software Engineer at **A.P. Moller - Maersk**
- Graduated in 2022 from **JSS Academy of Technical Education, Bengaluru, India**
- GSoD 2020 **@gRPC-Gateway**, GSoD 2021 **@Wechaty**, LFX Mentorship 2021 **@Moja Global**, and GSoC 2022 **@Keptn**
- Previously worked with **Lummo, redBus, and Economize**

: My name is Rajiv. I'm originally from Bihar, India, and currently work as a Software Engineer at A.P. Moller - Maersk in the Platform Engineering team in Bengaluru, India.
: I graduated in 2022 from JSS Academy of Technical Education, Bengaluru, India, with a degree in Information Science and Engineering.
: I started working with Go in 2020 when I was selected for Google Season of Docs (GSoD) with gRPC-Gateway.
: I am an open-source enthusiast and have contributed to various open-source projects and programs such as GSoD, LFX Mentorship, and GSoC.
: I have previously worked with Lummo, redBus, and Economize.

.link https://github.com/achille-roussel

- Career at **Twitch, Facebook, Segment, Twilio**
- Go developer since 2014
- Go contributor since 2023 (**GOOS=wasip1**)
- Open-source projects such as **wazero, wasi-go, etc**
- Co-Founder of [**dispatch.run**](https://docs.dispatch.run)

: My name is Achille. I'm originally from France, but I now live in San Francisco.
: I've been a Go developer for almost 10 years, and I started contributing to the Go project in 2023.
: Last year, I joined the team that develops and maintains the WebAssembly architecture of Go.
: Personally, I contributed to the implementation of WASI preview 1, which is what we are here to discuss with you.
: Finally, I'm also the co-founder of dispatch.run, where we are working on a platform to create reliable distributed systems.

## The story of how this talk happened

: Other and I have connected online in the Go community and thought it would be nice to come and tell the stories of Go and WebAssembly to a broader audience.
: As we were saying, Rajiv lives in India, and Achille lives in the US. We had never met in person before.
: So, open-source is really core to the story we're here to tell.
: Not only because Go is powered by an open-source community, but also because it's thanks to this community that the WASI port was created, and this talk happened.

## What is the Go programming language?

: Go is a multi-paradigm programming language oriented towards the needs of developing secure, production-quality applications.
: It is a language developed and maintained by Google as an open-source project.
: Most contributions today come from the open-source community.
: Every change to the language or standard library follows the same review and acceptance process, regardless of the submitter.

: Go is very popular for developing cloud services or networking applications in general.
: It is a compiled, memory-safe language with automated memory management and a focus on simplicity.
: Go is often described as easy to pick up; someone with prior experience in software development can usually become a productive Go developer within a week or two.
: If you've heard of Go before, you probably learned about the concurrency primitives that exist in the language, like goroutines and channels.
: Combined with a powerful runtime and standard library, this makes Go a very effective tool for developing reliable distributed systems.

: In this presentation, we also aimed to give you a glimpse into the world of Go.
: In particular, you will see depictions of little gophers hard at work in the slides.
: The gopher is the mascot for Go and also the term we use to refer to Go developers.
: If you've ever attended a presentation on the Go programming language, you may recognize the program we used to create this presentation.
: It is called "present" and is part of the extended Go toolkit, obviously written in Go.
: What I'm trying to convey here is that Go is more than just a language; it's an ecosystem of tools based on a programming language aimed at making developers more productive.

: In this ecosystem, when we refer to Go, we usually mean the core project maintained by Google.
: However, there are alternative compilers, most notably TinyGo.
: TinyGo is the Go compiler designed for resource-constrained environments and is an important project for the WebAssembly community, as we will discuss in more detail later.

## Using WebAssembly in Go

: Go has supported WebAssembly (Wasm) since the 1.11 release, which was in 2018.
: The initial support was for the js/wasm port, which allowed Go code to be compiled to Wasm and executed in web browsers.
: This was a significant milestone for the Go project, as it allowed developers to run high-performance, low-level code directly in web browsers at near-native speeds.
: However, it required a JavaScript execution environment, which was not always ideal.
: As the use of Wasm has grown, so have use cases outside of the browser.
: Many cloud providers are now offering services that allow users to execute Wasm executables directly, leveraging the new WebAssembly System Interface (WASI) syscall API.

## The WebAssembly System Interface

: WebAssembly (Wasm) is a binary instruction format originally designed for the web.
: It represents a standard that allows developers to run high-performance, low-level code directly in web browsers at near-native speeds.
: Go first added support for compiling to Wasm in the 1.11 release, through the js/wasm port.
: This allowed Go code compiled using the Go compiler to be executed in web browsers, but it required a JavaScript execution environment.

: As the use of Wasm has grown, so have use cases outside of the browser.
: Many cloud providers are now offering services that allow users to execute Wasm executables directly, leveraging the new WebAssembly System Interface (WASI) syscall API.

## History of WASI Support in the Go Toolchain

: I think it makes sense for me to narrate this part since I have first-hand experience.

: Back in January 2023, a Go contributor, Johan Brandhorst, posted a message on Slack asking if anyone was interested in contributing to WASI work, which had stalled for a few years.
: My friend and co-founder, Julien, and I replied to the message, and a few days later, we had a little group of 4 team members ready to pick up the WASI work.
: Imagine the situation: we had four engineers who had never worked together, had never worked on the Go compiler or runtime, and picked up an incomplete change that had massively diverged from the main branch.
: Let me tell you, we weren't necessarily set on a path with a lot of chances for success.
: Our task was first to split out the compiler from the runtime changes so we could submit individual proposals to the Go project and deliver incremental results.
: We created a proposal to add a compiler primitive called //go:wasmimport, which allows developers to declare imports from the code when compiling to WebAssembly.
: And a second proposal to add a new compilation target for WASI preview 1.
: As a side note, that's when we coined the term wasip1, which has now been reused in multiple other projects.

: While we were going through the development of wasip1, a major challenge was dealing with the difference in interpretation of the WASI spec in various runtimes and languages.
: Since TinyGo already had support for WASI, I thought "great!" I would use the combination of TinyGo and Wasmtime as the reference.
: Little did I know, the file system implementation of WASI in TinyGo was only partially completed.
: So while we were working on getting wasip1 in "Big Go," I also took a side quest to finish the wasip1 implementation in TinyGo in order to have a reference that we could compare to.

: Through the perseverance of the team, after a couple of months, we had the //go:wasmimport directive merged in, which we could use to implement wasip1 support in the Go runtime.
: As we made progress on the wasip1 implementation, more developers tagged along to contribute improvements to the implementation.
: Finally, the new wasip1 target went live in Go 1.21, which was released in September of last year, 2023.

: I want to take a minute to thank all the contributors who have participated in creating the wasip1 port of Go.
: Richard Musiol for the original WASI development that we based our work on.
: Johan Brandhorst and Evan Phoenix for spawning the team.
: Damian Gryski for his guidance on Go and help connecting with the Wasmtime folks.
: My friends and co-workers Chris O'Hara, Thomas Pelletier, and Julien Fabre for their work on the implementation.
: And also the members of the Go team for their review and insight during the development process.

: This is truly a team effort, from people who had mostly never met in person. To me, it is a great showcase of the power of open-source.

## Examples of using wasip1 in real-world programs

- How can we utilize it with Go?
: Ensure that you have installed at least version 1.21 of Go. For this demo, we'll use the wazero host to execute our binary.

.code main.go

$ GOOS=wasip1 GOARCH=wasm go build -o main.wasm main.go

$ wazero run main.wasm

Hello wasip1!

: In addition to the new wasm port, Go 1.21 introduces a new compiler directive: go:wasmimport.
: It instructs the compiler to translate calls to the annotated function into a call to the function specified by the host module name and function name.
: This feature is useful for giving Go programs access to host-provided APIs.
: It may not be super useful for everyday users, but it can be used to implement wasm, for example.

- Why is WASI useful for sqlc and its plugins?
: WASI is currently primarily useful for writing plugins in any language that can be compiled to Wasm and WASI, and then executed in any language with a Wasm/WASI virtual machine.
: There is a project called https://github.com/sqlc-dev/sqlc which generates type-safe code from SQL. In this project, we need a differential plugin to make things happen, like sqlc-gen-go, sqlc-gen-kotlin, sqlc-gen-python, etc.
: So for every release, they extract the Go, Python, Kotlin, etc., codegen into standalone respective particular language plugins sqlc-gen-go, sqlc-gen-kotlin, sqlc-gen-python, etc., which are then built using wasip1.
: This allows people to customize the output by forking just the particular language plugin, not the entire sqlc repository.
: Go can be compiled both as a plugin and as a plugin runner (using Wazero, for example). In the case of sqlc, they can run plugins compiled to WASI, and then they can write their own plugins in Go and compile them to WASI.
: The reason for using wasip1 is that it's a much smaller amount of code. Sometimes, people will fork the repo and then they can't merge in later changes because of something totally unrelated to the particular output plugin.

## Limitations of wasip1

: Wasm is single-threaded without parallelism. Although the scheduler can arrange goroutines to
: run concurrently and standard input/output/error operations are non-blocking, any host function calls will cause all goroutines to block until the call returns.

: A notable absence in the wasip1 API is a complete implementation of network sockets.
: wasip1 only provides functions for operating on already opened sockets, which limits support for key features of the Go standard library like HTTP servers.
: However, platforms such as Wasmer and WasmEdge have introduced extensions to the wasip1 API, enabling the opening of network sockets.
: Although these extensions are not integrated into the Go compiler, a third-party library, github.com/stealthrocket/net, has emerged.
: This library utilizes go:wasmimport to enable the use of net.Dial and net.Listen on compatible Wasm hosts, allowing for the creation of net/http servers and other network-related functionalities.

## When to use TinyGo vs Big Go in WASI?

: The primary reasons for people to use TinyGo for WebAssembly (Wasm) and WebAssembly System Interface (WASI) include its smaller binary size.
: The reason it compiles smaller binaries is a bit complicated, but essentially boils down to two factors: it doesn't implement all Go functionality, and it's built on top of LLVM instead of its own build system.
: Another reason users may want to use TinyGo is that it generally implements features ahead of Big Go. For example, TinyGo had support for WASI before Big Go.
: As a matter of fact, WASI preview 2 is already being implemented in TinyGo.
: It does support most things (it definitely supports goroutines), but it can sometimes break in unexpected ways. Go is generally a safer bet for production workloads, but if you are willing to accept a bit of risk, there are benefits.

## The future of Wasm in Go

: The Go team is working on a new version of the WASI port, wasip2, which will include support for network sockets and other features that were missing in wasip1.
: The new version will also include a new compiler directive, go:wasmexport, which will allow developers to export Go functions to the host environment.
: This will enable developers to write Go code that can be called from other languages running in the host environment.
: The new version will also include a new compilation target, GOARCH=wasm32, which will allow developers to compile Go code to Wasm for 32-bit architectures.
