# Empowering Go with WebAssembly System Interface (WASI) Unleashed
14th March 2024
Tags: wasm, wasi, wasip1
Summary: This presentation examines the current state of WebAssembly in Go, with a focus on WASI preview 1. It delves into the history of WASI development, the ecosystem of tools, and explores real-world applications.

Rajiv Ranjan Singh
Achille Roussel

## Agenda

- **What is Go?**
- **History of WASI in Go**
- **How to use wasip1?**
- **The future of WASI in Go**

## Speaker - Rajiv Ranjan Singh

.link https://github.com/iamrajiv

- Software Engineer at **A.P. Moller - Maersk**
- Graduated in 2022 from **JSS Academy of Technical Education, Bengaluru, India**
- **Google Season of Docs** 2020-2021, **Google Summer of Code** 2022
- Previously worked with **Lummo, redBus, and Economize**

: My name is Rajiv. I'm originally from Bihar, India, and currently work as a Software Engineer at A.P. Moller - Maersk in the Platform Engineering team in Bengaluru, India.
: I graduated in 2022 from JSS Academy of Technical Education, Bengaluru, India, with a degree in Information Science and Engineering.
: I started working with Go in 2020 when I was selected for Google Season of Docs (GSoD) with gRPC-Gateway.
: I am an open-source enthusiast and have contributed to various open-source projects and programs such as GSoD, LFX Mentorship, and GSoC.
: I have previously worked with Lummo, redBus, and Economize.

.image images/rajiv.png 250 _

## Speaker - Achille Roussel

.link https://github.com/achille-roussel

- Career at **Twitch, Facebook, Segment, Twilio**
- Go developer since 2014
- Go contributor since 2023 (**GOOS=wasip1**)
- Open-source maintainer on **wazero, wasi-go, wzprof...**
- Co-Founder of [**dispatch.run**](https://docs.dispatch.run)

: My name is Achille. I'm originally from France, but I now live in San Francisco.
: I've been a Go developer for almost 10 years, and I started contributing to the Go project in 2023.
: Last year, I joined the team that develops and maintains the WebAssembly architecture of Go.
: Personally, I contributed to the implementation of WASI preview 1, which is what we are here to discuss with you.
: Finally, I'm also the co-founder of dispatch.run, where we are working on a platform to create reliable distributed systems.

.image images/achille.png 200 _

## The story of how this talk happened

: We come from very different places and never had met in person before.
: <?> and I have connected online in the Go community and thought it would be nice to come and tell the stories of Go and WebAssembly to a broader audience.
: So, open-source is really core to the story we're here to tell.
: Not only because Go is powered by an open-source community, but also because it's thanks to this community that the WASI port was created, and this talk happened.

## What is Go?

- Multi-paradigm programming language
- Maintained by Google as an open-source project

.image images/GOOGLE.png 300 _

: Go is a multi-paradigm programming language oriented towards the needs of developing secure, production-quality applications.
: It is a language developed and maintained by Google as an open-source project.

## An example Go program

.code examples/main.go

- Simple syntax, easy to pick up
- Memory-safe with automated memory management
- Portable, compiles to a multitude of platforms

: TOOD: add image of OSX, linux, and wasi

: Instead of telling you a long story, let me show you an example.
: This is a full Go program to print a hello message, as you can see it is quite simple.
: Even if you've never looked at a Go program before, you'll be able to make sense of the code, Go is easy to pick up!
: Go has a rich standard library, and advanced concurrency primitives built into the language like goroutines and channels.
: And it is also very portable, it compiles to a multitude of targets, including webassembly.

## Go is more than a language

The **go** program is the entrypoint to the Go toolchain.
It standardizes how developers build and maintain their applications.

```
$ go build
```
```
$ go mod
```
```
$ go fmt
```
```
$ go test
```
```
$ go tool pprof
```

: The go program is the entrypoint of the Go toolchain.
: It standardizes how developers build and maintain their applications.
: Here I have listed a few commands that I use in my day-to-day work when I use Go.
: As you can see, it provides a lot of standard tooling for building, managing dependencies, formatting and testing the code, but also some more advanced tools like a builtin CPU and memory profiler.

## Go is also an ecosystem

- Many open-source projects are developed in Go
- Large portfolio of high-quality open-source libraries
- Alternate compilers like **TinyGo**
- **Wazero** as embedded WASI runtime

: TODO: add logos of popular open-source projects developed in Go: kubernetes, prometheus, tinygo, wazero, etc...

: But Go is a lot more than a language, it's an ecosystem of high-quality open-source tools and libraries that largely contribute to developer productivity.
: Beyond that, it's also a tool with a very wide breadth of applications.
: In particular, thanks to projects like TinyGo, which is the Go compiler for resource-constrained environments and an important project for the WebAssembly community as well.

.image images/GOPHER_SAFARI.png 200 _

## History of WASI Support in the Go Toolchain

- WebAssembly support added in 2018 (Go 1.11)
- WASI preview 1 target added in 2023 (Go 1.21)

: Now that we know more about Go, I'm going to take you on a journey through how the WASI preview 1 port was developed.
: Since a lot of your are software developers here, I'm sure you'll enjoy the story, as you've probably lived through similar ventures before.
: To get a birds-eye view of the timeline, WASM support was first added to Go in 2018
: These are five years and ten versions apart!
: It's because a big part of Go is developed by its community, and for a while, there weren't enough contributors available to finish it.
: That changed in January 2023, when a Go contributors, Johan Brandhorst, posted a message on Slack asking if anyone was interested in contributing to WASI work, which had stalled for a few years.

.image images/go-plus-wasi.png 400 _

## Task #1: Learn the Craft

- 4 contributors

- 2 proposals
  - **go:wasmimport**
    
    The new compiler directive that would allow us to develop WASI
    
  - **GOOS=wasip1**
    
    The new target platform to implement the Go runtime on top of WASI

- 1 partial implementation

.image images/GOPHER_SHARE.png 200 _

: My co-founder and I replied to the message, and a few days later, we had a little group of 4 team members ready to pick up the WASI work.
: Imagine the situation: we had four engineers who had never worked together on the Go compiler or runtime, and we picked up an abandonned branch where WASI development had started a few years before, but had massively diverged from upstream.
: Let me tell you, we weren't necessarily set on a path for success.
: Our task was first to split out the compiler from the runtime changes so we could submit individual proposals to the Go project and deliver incremental results.
: We submitted a first proposal to add a compiler primitive called go:wasmimport, which allows developers to declare imports from the code when compiling to WebAssembly.
: And a second proposal to add a new compilation target for WASI preview 1.
: As a side note, that's when we coined the term wasip1, which has now been reused in multiple other projects.

: TODO: image of 4 gophers?

## Task #2: Power Through

- Navigate the creativity of the open-source world!

.image images/This_is_Fine_Gopher.png 300 _

: While we were going through the development of wasip1, a major challenge was dealing with the difference in interpretation of the WASI spec in various runtimes and languages.
: Since TinyGo already had support for WASI, I thought to myself "great!" I could use the combination of TinyGo and Wasmtime as the reference.
: Little did I know, the file system implementation of WASI in TinyGo was only partially completed.
: So while we were working on getting wasip1 in "Big Go," I also took a side quest to finish the wasip1 implementation in TinyGo in order to have a reference that we could compare to.

## Task #3: Deliver the Product

- Changes started getting merged in
- More contributors joined to help push through the finish line

.image images/MovingGopher.png 300 _

: Through the perseverance of the team, after a couple of months, we had the go:wasmimport directive merged in, which we could use to implement wasip1 support in the Go runtime.
: As we made progress on the wasip1 implementation, more developers tagged along to contribute improvements.
: At this stage, we also started getting a lot of support from the Go team, and it really felt like we were going to pull it off!
: Finally, the new wasip1 target went live in Go 1.21, which was released in September of last year, 2023.

## Task #4: Celebrate!

.image images/GopherSpaceCommunity.png 400 _

: I want to take a minute to thank all the contributors who have participated in creating the wasip1 port of Go.
: If you're watching this talk, you know who you are, and know the amazing role you took in making this a reality.
: This is truly a team effort, from people who had mostly never met in person. To me, it is a great showcase of the power of open-source.

## Using the go:wasmimport directive

.code examples/wasmimport.go

.image images/NERDY.png 200 _

: We mentioned that the first addition was the compiler directive: go:wasmimport, and this is how we use it in Go.
: The program declares a Go function signature without the body of the function, preceeded with the directive declaring the names of the wasm module and the exported function that it links to.
: We can pass pointers into the linear program memory, and other primitive types, and the compiler takes care of the translation to webassembly types.
: As you can see, this is a fairly low-level directive, only library maintainers usually care to use it, and would expose higher level APIs that invoke the imports.

## Building Go program for wasip1

Simple two step process:
- go build with GOARCH=wasm and GOOS=wasip1
- run the compiled module with a WASI runtime

.code examples/main.go

    $ GOARCH=wasm GOOS=wasip1 go build -o main.wasm main.go
    $ wazero run main.wasm
    Hello wasip1!

: Now let's take a look at how we can build a Go program targeting wasip1.
: The GOARCH and GOOS environment variables are used to control the target platform, we set them to wasm and wasip1 to build a WASI module. It doesn't get much simpler than that!
: In this program, the go:wasmimport directive is used underneath by the Go runtime to interact with the host.
: And when we run our program with a runtime like wazero, we see our message print to the console.

## Advanced use of wasip1 in Go

- Why is WASI useful for sqlc and its plugins?
: WASI is currently primarily useful for writing plugins in any language that can be compiled to Wasm and WASI, and then executed in any language with a Wasm/WASI virtual machine.
: There is a project called https://github.com/sqlc-dev/sqlc which generates type-safe code from SQL. In this project, we need a differential plugin to make things happen, like sqlc-gen-go, sqlc-gen-kotlin, sqlc-gen-python, etc.
: So for every release, they extract the Go, Python, Kotlin, etc., codegen into standalone respective particular language plugins sqlc-gen-go, sqlc-gen-kotlin, sqlc-gen-python, etc., which are then built using wasip1.
: This allows people to customize the output by forking just the particular language plugin, not the entire sqlc repository.
: Go can be compiled both as a plugin and as a plugin runner (using Wazero, for example). In the case of sqlc, they can run plugins compiled to WASI, and then they can write their own plugins in Go and compile them to WASI.
: The reason for using wasip1 is that it's a much smaller amount of code. Sometimes, people will fork the repo and then they can't merge in later changes because of something totally unrelated to the particular output plugin.

## Limitations of wasip1

- Single threaded, all goroutines block during host function calls
- Limited socket support in WASI preview 1
- No compiler directive to declare exported functions

: The WASM architecture used in Go is single-threaded. Although the scheduler can arrange goroutines to run concurrently and standard input/output/error operations are non-blocking, any host function calls will cause all goroutines to block until the call returns.

: A notable absence in the wasip1 API is a complete implementation of network sockets.
: wasip1 only provides functions for operating on already opened sockets, which limits support for key features of the Go standard library like HTTP servers.
: However, platforms such as Wasmer and WasmEdge have introduced extensions to the wasip1 API, enabling the opening of network sockets.
: Although these extensions are not integrated into the Go compiler, a third-party library, github.com/stealthrocket/net, has emerged.
: This library utilizes go:wasmimport to enable the use of net.Dial and net.Listen on compatible Wasm hosts, allowing for the creation of net/http servers and other network-related functionalities.

.image images/GOPHER_ROCKS.png 200 _

## When to use Go vs TinyGo when targetting WASI?

- **Go**
  - Preferred when portability is the main priority

- **TinyGo**
  - Targets that require small binary footprint
  - Experimental WASI features (wasip2)

.image images/tinygo-logo.png 150 _

: The primary reasons for people to use TinyGo for WebAssembly (Wasm) and WebAssembly System Interface (WASI) include its smaller binary size.
: The reason it compiles smaller binaries is a bit complicated, but essentially boils down to two factors: it doesn't implement all Go functionality, and it's built on top of LLVM instead of its own build system.
: Another reason users may want to use TinyGo is that it generally implements features ahead of Big Go. For example, TinyGo had support for WASI before Big Go.
: As a matter of fact, WASI preview 2 is already being implemented in TinyGo.
: It does support most things (it definitely supports goroutines), but it can sometimes break in unexpected ways. Go is generally a safer bet for production workloads, but if you are willing to accept a bit of risk, there are benefits.

## The future of WASI in Go

Three main workstreams:

- **GOARCH=wasm32**
  
  A new WebAssembly 32-bits architecture for Go

- **go:wasmexport**
  
  To allow developers to declare custom exported functions

- **WASI preview 2**
  
  TinyGo contributors are working on an experimental support for wasip2

: TODO: add links to the proposals

.image images/GOPHERCON.png 150 _

: At this time, two proposals have been accepted by the Go team and are being worked on

: The Go team is working on a new version of the WASI port, wasip2, which will include support for network sockets and other features that were missing in wasip1.
: The new version will also include a new compiler directive, go:wasmexport, which will allow developers to export Go functions to the host environment.
: This will enable developers to write Go code that can be called from other languages running in the host environment.
: The new version will also include a new compilation target, GOARCH=wasm32, which will allow developers to compile Go code to Wasm for 32-bit architectures.
